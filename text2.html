
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
		<title></title>
		
		
	</head>
	<style type="text/css">
		* {
			margin: 0;
			padding: 0;
		}

	
	</style>
	<body>
		<!-- <select>
			<option value ="100">100</option>
		</select> -->
		
	</body>
	<script type="text/javascript">
		!function(){"use strict";var r=.5*(Math.sqrt(3)-1),e=(3-Math.sqrt(3))/6,t=1/6,a=(Math.sqrt(5)-1)/4,o=(5-Math.sqrt(5))/20;function i(r){var e;e="function"==typeof r?r:r?function(){var r=0,e=0,t=0,a=1,o=(i=4022871197,function(r){r=r.toString();for(var e=0;e<r.length;e++){var t=.02519603282416938*(i+=r.charCodeAt(e));t-=i=t>>>0,i=(t*=i)>>>0,i+=4294967296*(t-=i)}return 2.3283064365386963e-10*(i>>>0)});var i;r=o(" "),e=o(" "),t=o(" ");for(var n=0;n<arguments.length;n++)(r-=o(arguments[n]))<0&&(r+=1),(e-=o(arguments[n]))<0&&(e+=1),(t-=o(arguments[n]))<0&&(t+=1);return o=null,function(){var o=2091639*r+2.3283064365386963e-10*a;return r=e,e=t,t=o-(a=0|o)}}(r):Math.random,this.p=n(e),this.perm=new Uint8Array(512),this.permMod12=new Uint8Array(512);for(var t=0;t<512;t++)this.perm[t]=this.p[255&t],this.permMod12[t]=this.perm[t]%12}function n(r){var e,t=new Uint8Array(256);for(e=0;e<256;e++)t[e]=e;for(e=0;e<255;e++){var a=e+~~(r()*(256-e)),o=t[e];t[e]=t[a],t[a]=o}return t}i.prototype={grad3:new Float32Array([1,1,0,-1,1,0,1,-1,0,-1,-1,0,1,0,1,-1,0,1,1,0,-1,-1,0,-1,0,1,1,0,-1,1,0,1,-1,0,-1,-1]),grad4:new Float32Array([0,1,1,1,0,1,1,-1,0,1,-1,1,0,1,-1,-1,0,-1,1,1,0,-1,1,-1,0,-1,-1,1,0,-1,-1,-1,1,0,1,1,1,0,1,-1,1,0,-1,1,1,0,-1,-1,-1,0,1,1,-1,0,1,-1,-1,0,-1,1,-1,0,-1,-1,1,1,0,1,1,1,0,-1,1,-1,0,1,1,-1,0,-1,-1,1,0,1,-1,1,0,-1,-1,-1,0,1,-1,-1,0,-1,1,1,1,0,1,1,-1,0,1,-1,1,0,1,-1,-1,0,-1,1,1,0,-1,1,-1,0,-1,-1,1,0,-1,-1,-1,0]),noise2D:function(t,a){var o,i,n=this.permMod12,f=this.perm,s=this.grad3,v=0,h=0,l=0,u=(t+a)*r,d=Math.floor(t+u),p=Math.floor(a+u),M=(d+p)*e,m=t-(d-M),c=a-(p-M);m>c?(o=1,i=0):(o=0,i=1);var y=m-o+e,w=c-i+e,g=m-1+2*e,A=c-1+2*e,x=255&d,q=255&p,D=.5-m*m-c*c;if(D>=0){var S=3*n[x+f[q]];v=(D*=D)*D*(s[S]*m+s[S+1]*c)}var U=.5-y*y-w*w;if(U>=0){var b=3*n[x+o+f[q+i]];h=(U*=U)*U*(s[b]*y+s[b+1]*w)}var F=.5-g*g-A*A;if(F>=0){var N=3*n[x+1+f[q+1]];l=(F*=F)*F*(s[N]*g+s[N+1]*A)}return 70*(v+h+l)},noise3D:function(r,e,a){var o,i,n,f,s,v,h,l,u,d,p=this.permMod12,M=this.perm,m=this.grad3,c=(r+e+a)*(1/3),y=Math.floor(r+c),w=Math.floor(e+c),g=Math.floor(a+c),A=(y+w+g)*t,x=r-(y-A),q=e-(w-A),D=a-(g-A);x>=q?q>=D?(s=1,v=0,h=0,l=1,u=1,d=0):x>=D?(s=1,v=0,h=0,l=1,u=0,d=1):(s=0,v=0,h=1,l=1,u=0,d=1):q<D?(s=0,v=0,h=1,l=0,u=1,d=1):x<D?(s=0,v=1,h=0,l=0,u=1,d=1):(s=0,v=1,h=0,l=1,u=1,d=0);var S=x-s+t,U=q-v+t,b=D-h+t,F=x-l+2*t,N=q-u+2*t,C=D-d+2*t,P=x-1+.5,T=q-1+.5,_=D-1+.5,j=255&y,k=255&w,z=255&g,B=.6-x*x-q*q-D*D;if(B<0)o=0;else{var E=3*p[j+M[k+M[z]]];o=(B*=B)*B*(m[E]*x+m[E+1]*q+m[E+2]*D)}var G=.6-S*S-U*U-b*b;if(G<0)i=0;else{var H=3*p[j+s+M[k+v+M[z+h]]];i=(G*=G)*G*(m[H]*S+m[H+1]*U+m[H+2]*b)}var I=.6-F*F-N*N-C*C;if(I<0)n=0;else{var J=3*p[j+l+M[k+u+M[z+d]]];n=(I*=I)*I*(m[J]*F+m[J+1]*N+m[J+2]*C)}var K=.6-P*P-T*T-_*_;if(K<0)f=0;else{var L=3*p[j+1+M[k+1+M[z+1]]];f=(K*=K)*K*(m[L]*P+m[L+1]*T+m[L+2]*_)}return 32*(o+i+n+f)},noise4D:function(r,e,t,i){var n,f,s,v,h,l,u,d,p,M,m,c,y,w,g,A,x,q=this.perm,D=this.grad4,S=(r+e+t+i)*a,U=Math.floor(r+S),b=Math.floor(e+S),F=Math.floor(t+S),N=Math.floor(i+S),C=(U+b+F+N)*o,P=r-(U-C),T=e-(b-C),_=t-(F-C),j=i-(N-C),k=0,z=0,B=0,E=0;P>T?k++:z++,P>_?k++:B++,P>j?k++:E++,T>_?z++:B++,T>j?z++:E++,_>j?B++:E++;var G=P-(l=k>=3?1:0)+o,H=T-(u=z>=3?1:0)+o,I=_-(d=B>=3?1:0)+o,J=j-(p=E>=3?1:0)+o,K=P-(M=k>=2?1:0)+2*o,L=T-(m=z>=2?1:0)+2*o,O=_-(c=B>=2?1:0)+2*o,Q=j-(y=E>=2?1:0)+2*o,R=P-(w=k>=1?1:0)+3*o,V=T-(g=z>=1?1:0)+3*o,W=_-(A=B>=1?1:0)+3*o,X=j-(x=E>=1?1:0)+3*o,Y=P-1+4*o,Z=T-1+4*o,$=_-1+4*o,rr=j-1+4*o,er=255&U,tr=255&b,ar=255&F,or=255&N,ir=.6-P*P-T*T-_*_-j*j;if(ir<0)n=0;else{var nr=q[er+q[tr+q[ar+q[or]]]]%32*4;n=(ir*=ir)*ir*(D[nr]*P+D[nr+1]*T+D[nr+2]*_+D[nr+3]*j)}var fr=.6-G*G-H*H-I*I-J*J;if(fr<0)f=0;else{var sr=q[er+l+q[tr+u+q[ar+d+q[or+p]]]]%32*4;f=(fr*=fr)*fr*(D[sr]*G+D[sr+1]*H+D[sr+2]*I+D[sr+3]*J)}var vr=.6-K*K-L*L-O*O-Q*Q;if(vr<0)s=0;else{var hr=q[er+M+q[tr+m+q[ar+c+q[or+y]]]]%32*4;s=(vr*=vr)*vr*(D[hr]*K+D[hr+1]*L+D[hr+2]*O+D[hr+3]*Q)}var lr=.6-R*R-V*V-W*W-X*X;if(lr<0)v=0;else{var ur=q[er+w+q[tr+g+q[ar+A+q[or+x]]]]%32*4;v=(lr*=lr)*lr*(D[ur]*R+D[ur+1]*V+D[ur+2]*W+D[ur+3]*X)}var dr=.6-Y*Y-Z*Z-$*$-rr*rr;if(dr<0)h=0;else{var pr=q[er+1+q[tr+1+q[ar+1+q[or+1]]]]%32*4;h=(dr*=dr)*dr*(D[pr]*Y+D[pr+1]*Z+D[pr+2]*$+D[pr+3]*rr)}return 27*(n+f+s+v+h)}},i._buildPermutationTable=n,"undefined"!=typeof define&&define.amd&&define(function(){return i}),"undefined"!=typeof exports?exports.SimplexNoise=i:"undefined"!=typeof window&&(window.SimplexNoise=i),"undefined"!=typeof module&&(module.exports=i)}();
	</script>
	<script type="text/javascript">
		"use strict"

const {
	abs,
	acos,
	asin,
	atan,
	atan2,
	ceil,
	cos,
	floor,
	max,
	min,
	PI,
	pow,
	random,
	round,
	sin,
	sqrt,
	tan
} = Math
const HALF_PI = 0.5 * PI
const QUART_PI = 0.25 * PI
const TAU = 2 * PI
const TO_RAD = PI / 180
const G = 6.67 * pow(10, -11)
const EPSILON = 2.220446049250313e-16
const rand = n => n * random()
const randIn = (_min, _max) => rand(_max - _min) + _min
const randRange = n => n - rand(2 * n)
const fadeIn = (t, m) => t / m
const fadeOut = (t, m) => (m - t) / m
const fadeInOut = (t, m) => {
	let hm = 0.5 * m
	return abs((t + hm) % m - hm) / hm
}
const dist = (x1, y1, x2, y2) => sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2))
const angle = (x1, y1, x2, y2) => atan2(y2 - y1, x2 - x1)
const lerp = (a, b, t) => (1 - t) * a + t * b
const clamp = (n, _min, _max) => min(max(n, _min), _max)
const norm = (n, _min, _max) => (n - _min) / (_max - _min)
const fract = n => n - (n | 0)
const vh = p => p * window.innerHeight * 0.01
const vw = p => p * window.innerWidth * 0.01
const vmin = p => min(vh(p), vw(p))
const vmax = p => max(vh(p), vw(p))
const intToRGBA = n => {
	let r, g, b, a

	n >>>= 0

	r = (n & 0xff000000) >>> 24
	g = (n & 0xff0000) >>> 16
	b = (n & 0xff00) >>> 8
	a = (n & 0xff) / 255

	return `rgba(${[r, g, b, a].join()})`
}
const drawTypes = {
	FILL: 'fill',
	STROKE: 'stroke'
}
const textAlignTypes = {
	CENTER: 'center',
	END: 'end',
	LEFT: 'left',
	RIGHT: 'right',
	START: 'start'
}
const textBaselineTypes = {
	ALPHABETIC: 'alphabetic',
	BOTTOM: 'bottom',
	HANGING: 'hanging',
	MIDDLE: 'middle',
	TOP: 'top'
}

Array.prototype.lerp = function(t = [], a = 0) {
	this.forEach((n, i) => (this[i] = lerp(n, t[i], a)))
}

Float32Array.prototype.get = function(i = 0, n = 0) {
	const t = i + n

	let r = []

	for (; i < t; i++) {
		r.push(this[i])
	}

	return r
}

class PropsArray {
	constructor(count = 0, props = [], type = 'float') {
		this.count = count
		this.props = props
		this.spread = props.length // TODO: Need to implement indexing based on spread
		this.values = type === 'float'
			? new Float32Array(count * props.length)
			: new Uint32Array(count * props.length)
	}
	get length() {
		return this.values.length
	}
	set(a = [], i = 0) {
		this.values.set(a, i)
	}
	setMap(o = {}, i = 0) {
		this.set(Object.values(o), i)
	}
	get(i = 0) {
		return this.values.get(i, this.spread)
	}
	getMap(i = 0) {
		return this.get(i).reduce(
			(r, v, i) => ({
				...r,
				...{ [this.props[i]]: v }
			}),
			{}
		)
	}
	forEach(cb) {
		let i = 0
		
		for (; i < this.length; i += this.spread) {
			cb(this.get(i), i, this)
		}
	}
	map(cb) {
		let i = 0
		
		for (; i < this.length; i += this.spread) {
			this.set(cb(this.get(i), i, this), i)
		}
	}
	async* read() {
		let i = 0
		
		for (; i < this.length; i += this.spread) {
			yield { index: i, value: this.get(i) }
		}
	}
}

function createOffscreenCanvas (width, height) {
	let _canvas

	if (typeof OffscreenCanvas !== undefined) {
		_canvas = new OffscreenCanvas(parseFloat(width), parseFloat(height))
	} else {
		_canvas = createCanvas(width, height)
	}

	return _canvas
}

function createCanvas (width, height) {
	const canvas = document.createElement('canvas')

	canvas.width = width
	canvas.height = height

	return canvas
}

function createContext2D (width = innerWidth, height = innerHeight, contextAttributes) {
	return createCanvas(width, height).getContext('2d', contextAttributes)
}

function createOffscreenContext2D (width = innerWidth, height = innerHeight, contextAttributes) {
	return createOffscreenCanvas(width, height).getContext('2d', contextAttributes)
}

function createRenderingContext (width, height) {
	const contextAttributes = {
		desynchronized: true,
		willReadFrequently: true
	}

	const ctx = createContext2D(width, height, contextAttributes)
	const buffer = createOffscreenContext2D(width, height, contextAttributes)

	ctx.canvas.style.position = 'absolute'

	document.body.appendChild(ctx.canvas)

	return {
		buffer,
		ctx
	}
}

	
"use strict";

const particleCount = 2000;
const particleProps = [
    "x",
    "y",
    "z",
    "vx",
    "vy",
    "vz",
    "life",
    "ttl",
    "speed"
];
const rangeY = 100;
const rangeZ = 200;
const baseTTL = 50;
const rangeTTL = 200;
const baseHue = rand(360);
const rangeHue = 100;
const xc = 0.0005;
const yc = 0.0005;
const zc = 0.0005;
const tc = 0.0005;
const noiseSteps = ceil(rand(4)) + 4;
const backgroundColor = "hsla(0,0%,0%,0.5)";
const { buffer, ctx } = createRenderingContext()

let center;
let tick;
let simplex;
let particles;

function setup() {
	center = [];
	resize();
	initParticles();

	draw();
}

function initParticles() {
	tick = 0;
	simplex = new SimplexNoise();
	particles = new PropsArray(particleCount, particleProps);

	let i = 0;
	
	for (; i < particles.length; i += particleProps.length) {
		initParticle(i);
	}
}

function initParticle(i) {
	let x, y, z, vx, vy, vz, life, ttl, speed, radius, hue;

	x = rand(buffer.canvas.width);
	y = center[1] + randIn(-rangeY, rangeY);
	z = rand(rangeZ);
	vx = 0;
	vy = 0;
	vz = 0;
	life = 0;
	ttl = baseTTL + rand(rangeTTL);
	speed = 0;

	particles.set([x, y, z, vx, vy, vz, life, ttl, speed], i);
}

function drawParticles() {
	let i = 0;

	for (; i < particles.length; i += particleProps.length) {
		updateParticle(i);
	}
}

function updateParticle(i) {
	let n, theta, phi, cosPhi, x2, y2, z2, width, hue;

	let [x, y, z, vx, vy, vz, life, ttl, speed] = particles.get(i);

	n = simplex.noise4D(x * xc, y * yc, z * zc, tick);
	theta = n * TAU * noiseSteps;
	phi = (0 - n) * PI * noiseSteps;
	cosPhi = cos(phi);
	vx = lerp(vx, cos(theta) * cosPhi, 0.0725);
	vy = lerp(vy, sin(phi), 0.0725);
	vz = lerp(vz, sin(theta) * cosPhi, 0.0725);
	x2 = x + vx * speed;
	y2 = y + vy * speed;
	z2 = z + vz * speed;
	width = 0.015 * z2 + 2;
	speed = lerp(speed, 0.05 * z2, 0.15);
	hue = baseHue + speed * 0.035 * rangeHue;

	drawParticle(x, y, z, x2, y2, life, ttl, width, hue);

	life++;

	particles.set([x2, y2, z2, vx, vy, vz, life, ttl, speed], i);

	(checkBounds(x, y, width) || life > ttl) && initParticle(i);
}

function drawParticle(x, y, z, x2, y2, life, ttl, width, hue) {
	buffer.save();
	buffer.lineWidth = width;
	buffer.strokeStyle = `hsla(${hue + clamp(z, 0, 180)},${clamp(z, 10, 60)}%,${clamp(z, 10, 50)}%,${fadeInOut(life, ttl) * (0.01 * clamp(z, 50, 100))})`;
	buffer.beginPath();
	buffer.moveTo(x, y);
	buffer.lineTo(x2, y2);
	buffer.stroke();
	buffer.closePath();
	buffer.restore();
}

function checkBounds(x, y, r) {
	return x > r + buffer.canvas.width || x < -r || y > r + buffer.canvas.height || y < -r;
}

function resize() {
	const { innerWidth, innerHeight } = window;

	buffer.canvas.width = innerWidth;
	buffer.canvas.height = innerHeight;

	buffer.drawImage(ctx.canvas, 0, 0);

	ctx.canvas.width = innerWidth;
	ctx.canvas.height = innerHeight;

	ctx.drawImage(buffer.canvas, 0, 0);

	center[0] = 0.5 * buffer.canvas.width;
	center[1] = 0.5 * buffer.canvas.height;
}

function renderGlow() {
	ctx.save();
	ctx.filter = "blur(8px) brightness(200%)";
	ctx.globalCompositeOperation = "lighter";
	ctx.drawImage(buffer.canvas, 0, 0);
	ctx.restore();

	ctx.save();
	ctx.filter = "blur(4px) brightness(200%)";
	ctx.globalCompositeOperation = "lighter";
	ctx.drawImage(buffer.canvas, 0, 0);
	ctx.restore();
}

function renderToScreen() {
	ctx.save();
	ctx.globalCompositeOperation = "lighter";
	ctx.drawImage(buffer.canvas, 0, 0);
	ctx.restore();
}

function drawBackground() {
	buffer.clearRect(0, 0, buffer.canvas.width, buffer.canvas.height);

	ctx.fillStyle = backgroundColor;
	ctx.fillRect(0, 0, buffer.canvas.width, buffer.canvas.height);
}

function draw() {
	tick += tc;

	drawBackground();
	drawParticles();
	renderToScreen();
	renderGlow();

	window.requestAnimationFrame(draw);
}

window.addEventListener("load", setup);
window.addEventListener("resize", resize);


	var particleAlphabet = {
	Particle: function(x, y) {
		this.x = x;
		this.y = y;
		this.radius = 3.5;
		this.draw = function(ctx) {
			ctx.save();
			ctx.translate(this.x, this.y);
			ctx.fillStyle = 'white';
			ctx.fillRect(0, 0, this.radius, this.radius);
			ctx.restore();
		};
	},
	init: function(fontSize,time) {
		particleAlphabet.canvas = document.querySelector('canvas');
		particleAlphabet.ctx = particleAlphabet.canvas.getContext('2d');
		particleAlphabet.W = window.innerWidth;
		particleAlphabet.H = window.innerHeight;
		particleAlphabet.particlePositions = [];
		particleAlphabet.particles = [];
		particleAlphabet.tmpCanvas = document.createElement('canvas');
		particleAlphabet.tmpCtx = particleAlphabet.tmpCanvas.getContext('2d');

		particleAlphabet.canvas.width = particleAlphabet.W;
		particleAlphabet.canvas.height = particleAlphabet.H;
		particleAlphabet.fontSize=fontSize
		setInterval(function(){
			particleAlphabet.changeLetter();
			particleAlphabet.getPixels(particleAlphabet.tmpCanvas, particleAlphabet.tmpCtx);
		}, time);

		particleAlphabet.makeParticles(1000);
		particleAlphabet.animate();
	}, 
	currentPos: 0,
	changeLetter: function() {
		var letters = '科技无限非你莫鼠',
			letters = letters.split('');
		particleAlphabet.time = letters[particleAlphabet.currentPos];
		particleAlphabet.currentPos++;
		if (particleAlphabet.currentPos >= letters.length) {
			particleAlphabet.currentPos = 0;
		}
	},
	makeParticles: function(num) {
		for (var i = 0; i <= num; i++) {
			particleAlphabet.particles.push(new particleAlphabet.Particle(particleAlphabet.W / 2 + Math.random() * 400 - 200, particleAlphabet.H / 2 + Math.random() * 400 -200));
		}
	},
	getPixels: function(canvas, ctx) {
		var keyword = particleAlphabet.time,
			gridX = 5,
			gridY = 8;
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
		 ctx.fillStyle = 'red';
		ctx.font = ` bold ${particleAlphabet.fontSize}px Noto Serif`;
		// var gradient=ctx.createLinearGradient(0,0,canvas.width,0);
		// gradient.addColorStop("0","magenta");
		// gradient.addColorStop("0.5","blue");
		// gradient.addColorStop("1.0","red");
		// // 用渐变填色
		// ctx.fillStyle=gradient;
		ctx.fillText(keyword, canvas.width / 2 - ctx.measureText(keyword).width / 2, canvas.height / 2 + 10);
		var idata = ctx.getImageData(0, 0, canvas.width, canvas.height);
		var buffer32 = new Uint32Array(idata.data.buffer);
		if (particleAlphabet.particlePositions.length > 0) particleAlphabet.particlePositions = [];
		for (var y = 0; y < canvas.height; y += gridY) {
			for (var x = 0; x < canvas.width; x += gridX) {
				if (buffer32[y * canvas.width + x]) {
					particleAlphabet.particlePositions.push({x: x, y: y});
				}
				
			}
		}
		
	},
	animateParticles: function() {
		var p, pPos;
		for (var i = 0, num = particleAlphabet.particles.length; i < num; i++) {
			p = particleAlphabet.particles[i];
			pPos = particleAlphabet.particlePositions[i];
			if (particleAlphabet.particles.indexOf(p) === particleAlphabet.particlePositions.indexOf(pPos)) {
			p.x += (pPos.x - p.x) * .3;
			p.y += (pPos.y - p.y) * .3;
			particleAlphabet.ctx.fillStyle = 'red';
			p.draw(particleAlphabet.ctx);
			
			
		}
		}
	},
	animate: function() {
		requestAnimationFrame(particleAlphabet.animate);
		particleAlphabet.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
		particleAlphabet.ctx.fillRect(0, 0, particleAlphabet.W, particleAlphabet.H);
		particleAlphabet.animateParticles();
	}
};
//init(fontSize,time,bgColor)
window.onload = particleAlphabet.init(250,1000);
	</script>
</html>
